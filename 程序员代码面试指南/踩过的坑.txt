1.值类型包括：结构体，字符串，数组; 引用类型：切片，管道，map,指针
2.var this *Mystack 是错的，不能操作没用合法指向的内存
3.else 后面不能接条件语句 只能是else {}
4.切片作为函数参数，通过append添加元素，有可能会更改地址
	1）添加的数据元素长度超过切片参数的容量，则会另开辟空间，重新分配底层数组，并复制数据
		函数中的此切片和元切片的地址不同，此切片另外开辟新的内存，函数运行结束，内存释放，不会影响原切片的内容
	2）否则原切片与函数中的切片指向同一地址，会影响切片的内容
	3）切片本身就是一个指针，（内存保存指向切片的首地址）
5.深入理解递归的思想：
	递归的两个条件：1）可以通过递归来缩小问题的规模，且新问题与原问题有着相同的形式（自身调用）
				 2） 存在一种简单的情景，可以使递归在简单情景下退出 （递归出口）
	递归的过程跟栈的原理是一致的，递归调用就是通过栈这种数据结构完成的。整个过程中实际上就是一个栈的入栈和出栈问题。
	我们不需要关心这个栈的实现，这个过程是由系统来完成的。递归中的递就是入栈，递进，归就是出栈，回归。
6.自己定义的包只能放在/GOPHTH或者/GOROOT下
7.在使用interface表示任何类型时，如果要将interface转化为某一类型，直接强制转换是不行的，需要进行类型断言
  两种断言方式：1）var t1 interface{}=2 v,ok := t1.(int) if ok {fmt.println("int:",v)}  安全类型断言
			 2）var t2 interface{} = "abc" switch t2.(type) case string: fmt.println("string:",string) 不安全类型断言
8.重新定义了stack的定义，将接口类型变为数组了，省略了类型断言，此时拥有的方法有Pop,Push,Peek,Len四种方法。
9.匿名函数func(){}在结束时需要加()代表执行
